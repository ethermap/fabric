<!DOCTYPE html>
<html lang="en">
    <head>
		<title>Origin Matrix</title>
		<base href="" target="_blank">
        <meta charset="utf-8">
        <style>
            body{
            	background-color:#111133;
            	color:white;
            }
        </style>
    </head>

    <body> 
		<div style="font-size:160px; color:#99CCFF;">Org Mtrx</div>
        <script type="module">
			
			import KeyCache from '/keycache/keycache.js';
			import fabric from './fabric.js';
			import * as util from './drivers/util.js'
			//import { auth } from "./drivers/vehicle_generic_esm.mjs"
			import { OriginMatrix } from '/x_modules/frame/originmatrix.js'

			var om = new OriginMatrix();
			
			window.addEventListener( 'load' , async function(){
				
				// SIGNING CREDENTIALS PROVIDER
				var creds = new KeyCache();
				await creds.loginAndLoad( 
					[ ...String(window.location) ][37] , 
					[ ...String(window.location) ][37] );



				

				var ncr = creds.get('neo')
				var k = 3;

				var followed_up = false;
			    fabric.addEventListener( 'fabricEvent' , function( e ){
			        var data=e.detail;
					console.log('onFabricEvent: ',e.detail.method , '  UUID:', e.detail.uuid , '  payload:', e.detail.payload )
					console.log('|' )			
			        var i=0;

					// will there ever be a situation where nodes of different types are added ? 
					//  Add Key from KeyCache
					//  Add MAP from KeyCache
					//  Add list from NEO4J 
					//  Add All Artifacts from keyCache  safely 
					//  Add git-Repos from GIT list 
	
					var test_map = {
						nodes:[
							{
								nid:0,
								title:'zero'
							
							},
							{
								nid:1,
								title:'one'
							}
						],
						links:[
							{
								nid:99,
								nidStart:0,
								nidEnd:1
							}
						],
						meta:{
							origin:'test',
							foreign_id:'nid',
							foreign_a:'nidStart',
							foreign_b:'nidEnd'
						}
					}
					om.mergeMap( test_map );
					om.mergeMap( e.detail.payload )
									

					
					if ( ! followed_up ){ 
						fabric.mergeIntent( { 
							uuid:'neo_origin_test',
							brand:'neo',
							module:'neo',
							method:'query',
							pattern:'()--(:Satellite)',
							payload:{ uuid:'4:18de4a64-650a-4f3d-9657-0526a5183d76:955' ,  a:'rtr' , b:'f4f4' }
						} ); 		
						
						followed_up=true;
					}else{
						om.printInventory();
					}
					

					
			    })						
		
				var obj_N =  creds.mergeArtifacts( { 
					uuid:'neo_origin_test',
					brand:'neo',
					module:'neo',
					method:'query',
					pattern:'(:Star)--(:Moon)',
					payload:{ uuid:'4:18de4a64-650a-4f3d-9657-0526a5183d76:955' ,  a:'rtr' , b:'f4f4' }
				});
				
				obj_N.uuid = 'neo_origin_test'; // this is override hack cause  merge Artifacts is clobbering uuid 
				fabric.mergeIntent( obj_N ); 				
				//await util.sleep(3000);

			
				
			});
		</script>













		
		
		<!-- Generated by the server -->
		<script id="datax" type="application/json">{"userId":1234,"userName":"John Doe","memberSince":"2000-01-01T00:00:00.000Z"}
		</script>
		<!-- Static -->
		<script>
		  const userInfo = JSON.parse( document.getElementById("datax").text );
		  //console.log("User information: %o", userInfo);
			
			    // DESIRED RETURNS: 
			    // Entity.domain new Adderss and priv-key
			    // Entity.domain existing-price-cluster
			    // Entity.domain.xclass / cluster  time-series 
			    //fabric.mergeIntent(  { domain:'crabauto', driver:'crabauto',                    fn:'fetchTicker' , uuid:'0x1c2c2c22'   } );
			    //fabric.mergeIntent(  { domain:'crabauto', driver:'crabauto',                    fn:'fetchTicker' , uuid:'0x1c2c2c22'   } );
			    //fabric.postMessage ? 
			
			    // whats better 
			    // workers[ driver ][ carrier ] = {} 
			    // workers[ uuid ] = {}
			
						    
			    //fabric.mergeIntent(  { driver:'ethers', domain:'ethereum',  fn:'init' , symbol:'ETH/USD' } );
			    //fabric.mergeIntent(  { driver:'ccxt', domain:'binanceus', fn:'init' , symbol:'BTC/USD' } );
			    //fabric.publishIntent(  { domain:['ccxt','coinbase','BTC/USD','init'] } );
			    //fabric.publishIntent(  { domain:'ccxt.coinbase.btc.close' } );
			    
			    //fabric.echoFunction(  { seek:nodeIDparamDomain[ domain, symbol ]( x,y,z*,s,t ) . demand:priceVector   })
			    //fabric.spawnRequest(  { domain:symbol:xclass } )
			
			    //fabric.publishIntent( { domain:'x', symbol:'XYZ', xclass:'priceTelemetryObject'  } );
			    //fabric.addEventListener( 'domain.event' , function( e ){ } )
			    
			    /*
			    fabric.addEventListener( 'message' , function( e ){    
			        var object_vector = e.data.domain + '.' +e.data.xclass;
			        isoModel.pushUpdate( object_vector , e.data.tick  );
			    });    */

				// 3 WAY RESOLUTION STYLE 
				// API.getRes( userIn )
				// 	.then( (obj) => {   } )
				// 	.catch( err => console.log )
				// 	.finally( () => console.log )
						        
			
				// var domain=data.domain;
			        // var symbol=data.symbol;
			        // var xclass=data.xclass;

				// loginAndLoad(  return_pair() )
				// loginAndLoad( hash_param_1 <<< *3, hash_param_2 >>> *3 )
				// loginAndLoad( hash_param_1 <<< *3, hash_param_2 >>> *3 )
				// SHould not pass creds ref ( keycache )
				// fabric.signer( creds ) 
				// fabric.singer( vault )			
				// await fabric.mergeIntent(  { dom:'binanceus' , carrier:'binanceus', driver:'ccxt',  method:'init' ,        uuid:'0x1c2c2c22'   } );
				// init / launch of each worker should happen automatically based on existence of intent: 
				// await fabric.mergeIntent( { brand:'ethereum' , uuid:'0x1c2c2c22' , symbol:'ETH/USDT'   } )
				// fabric.facilitate
				// fabric.support( )
				// fabric.mergeIntent( )
				// await fabric.mergeIntent( creds.mergeCredential( { 
				// await fabric.mergeIntent( { ...creds.keySelect( 'dom' )[0]  
				// 		driver:'github_esm',	
				// 		method:'smallList' } ) )
				// function  mergeCredentialsAndSpawn( obj ){
				//
				//   fabric.mergeIntent(   { ...creds.keySelect( 'dom' , obj.dom )[0] }  , ...obj ) 
				// }

			
		</script>

	</body>
	
</html>

